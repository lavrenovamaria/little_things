# little_things

<details>
  <summary> Что именно является константой? “Что” — это всегда то, что находится перед квалификатором const </summary>

## int const*(лучше) и const int * это указатель на константный инт

Это означает, что объявляемая переменная является указателем, указывающим на постоянное целое число. По сути, это означает, что указатель указывает на значение, которое не следует изменять. Квалификатор ```const``` не влияет на указатель в этом сценарии, поэтому указатель может указывать на какой-либо другой адрес.
```c
int main()
{
    const int q = 5;
    printf("First const int q is %d\n", q);
    printf("Address of q: %p\n", &q);
    printf("------------------------");
    printf("\n");
    int const* p = &q;
    printf("Second const* p itself is nothing %ls\n", p);
    printf("\n");
    printf("Second const* p after turn to 5(printed as *p): %d\n", *p);
    printf("Address of p: %p\n", &p);
    printf("------------------------");
    printf("\n");
    //Compilation error  
    //*p = 7;
  
    const int q2 = 7;
    printf("Third const int q2 is %d\n", q2);
    printf("Address of q2: %p\n", &q2);
    //Valid
    p = &q2; 
    printf("Third const* p after turn to 7(printed as *p): %d\n", *p);
    printf("Third const* p itself is nothing %ls\n", p);
    printf("\n");
    printf("Address of p: %p\n", &p);
      
    return 0;
}
```
![Screenshot from 2022-05-06 11-58-41](https://user-images.githubusercontent.com/84707645/167103544-74c852e3-00dd-4a8c-8625-37350317c481.png)

## int *const это константный указатель на int
```c
int main()
{
    int a = 5, b = 10, c = 15;

	const int* foo;
	// pointer to constant int.
	foo = &a;
	// assignment to where foo points to.

	/* dummy statement*/
	*foo = 6;
	// the value of a can´t get changed through the pointer.

	foo = &b;
	// the pointer foo can be changed.



	int *const bar = &c;
	// constant pointer to int 
	// note, you actually need to set the pointer 
	// here because you can't change it later ;)

	*bar = 16;            // the value of c can be changed through the pointer.    

	/* dummy statement*/
	bar = &a;             // not possible because bar is a constant pointer.  
}
```


## const int* const и int const* const — константный указатель на константное целое число
Это означает, что объявляемая переменная является константным указателем, указывающим на 		постоянное целое число. По сути, это означает, что постоянный указатель указывает на постоянное 	значение. Следовательно, ни указатель не должен указывать на новый адрес, ни значение, на которое 	указывает указатель, не должно изменяться.
Первое ключевое слово const может находиться в любой части типа данных, поэтому const int* const 	эквивалентно int const* const.
</details>



<details>
  <summary> Метод свойства Java setProperty() </summary>
	
	
Метод setProperty() используется для установки заданного элемента значения (val_ele), связанного с заданным ключевым элементом (key_ele), когда ни один элемент значения не связан ранее, в противном случае он заменяет старое значение заданным значением для данного ключа этого свойства.

```public Object setProperty(String key, String value)```

Строка key_ele — представляет ключевой элемент, для которого должно быть установлено значение.
	
Строка val_ele — представляет элемент значения для данного ключа.

Тип возвращаемого значения метода — Object , он возвращает старое значение, связанное с данным ключом, если он существует, в противном случае он возвращает null.

```java
import java.io.*;
import java.util.*;

public class SetPropertyOfProperties {
	public static void main(String arg[]) throws Exeption {
	Properties prop = new Properties();
	prop.put("10", "C");
	prop.put("20", "C++");
	prop.put("30", "JAVA");
	prop.put("40", "PHP");
	prop.put("50", "SDFC");
	
	Object ob = prop.setProperty("20", "OOPS")
	
	System.out.println("prop.setProperty(20, OOPS): " + ob);
	
	prop.list(System.out);
	}
}
```

```
prop.setProperty(20, OOPS): C++
--listing properties--
50=SFDC
40=PHP
30=JAVA
20=OOPS
10=C
```
	
</details>

<details>
  <summary> Менеджер безопасности Java SecurityManager </summary>
  
SecurityManager — это механизм управления безопасностью, предоставляемый java, который можно использовать для контроля разрешений на некоторые операции каждого из наших классов.

При запуске неизвестной Java-программы в программе может быть вредоносный код (удаление системных файлов, перезагрузка системы и т. д.) Для того чтобы запуск вредоносного кода не повлиял на систему, необходимо контролировать разрешения запущенного кода. В это время необходимо включить Java Security Manager.

Например, если в сервлете tomcat есть такой код, как System.exit(), то будет отправлен запрос, который приведет к выключению нашей виртуальной машины, и tomcat тоже будет закрыт. мы можем установить разрешения. , потому что в методе System.exit() он будет проверять, есть ли у вызываемого класса разрешение, и если разрешения нет, ему будет отказано.
	
</details>


<details>
  <summary> public static native long nanoTime() </summary>
	
  Возвращает текущее значение источника времени с высоким разрешением работающей виртуальной машины Java в наносекундах.
	
  ```
  For example, to measure how long some code takes to execute:
 	long startTime = System.nanoTime();  
	// ... the code being measured ...  
	long elapsedNanos = System.nanoTime() - startTime;
  ```
	
System.nanoTime() основан на тактовом цикле ядра процессора, и время его запуска неизвестно, в интернете есть статья о том, что оно рассчитывается от времени запуска ядра процессора, есть скрытые опасности в использовании System.nanoTime() для измерения времени. Например, при работе на многоядерном процессоре разные вызовы могут получать время разных ядер и время запуска различных ядер многоядерного процессора Вероятно, не совсем согласованно, что может привести к ошибкам синхронизации.
	
</details>

<details>
  <summary> ConfigurableApplicationContext </summary>
	
ApplicationContext определяет базовые спецификации расширенных контейнеров, это главный интерфейс спринга, описывающий контейнер внедрения зависимостей. Фактически, он не наследует напрямую базовый контейнер BeanFactory. Видно, что прямой родительский интерфейс ApplicationContext значительно расширяет BeanFactory, в том числе:

Регистрация и публикация событий
Парсинг сообщений
Парсинг ресурсов
Hierarchical Bean Factory
Listener
Благодаря вышеприведенному расширению мы можем в основном узнать характеристики расширенного контейнера IOC(Инверсия управления (англ. Inversion of Control, IoC)), что также является ключевой частью изучения всего контейнера ApplicationContext.
	

![image](https://user-images.githubusercontent.com/84707645/190183639-132fd544-b34f-4dba-9390-94c16d164f68.png)
	
1. [ApplicationContext](https://blog.csdn.net/ligel136738/article/details/113533132?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522166316207716782388017187%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=166316207716782388017187&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_click~default-1-113533132-null-null.142^v47^pc_rank_34_default_2,201^v3^control_1&utm_term=ConfigurableApplicationContext&spm=1018.2226.3001.4187)
- Inherited from ListableBeanFactory interface: factory methods for accessing application components
	
- Inherited from the ResourceLoader interface: load file resources in a generic way
	
- Inherited from the ApplicationEventPublisher interface: registering and publishing events
	
- Inherited from the MessageSource interface: process messages, support internationalization

Определенный из контекста родительского приложения всегда будет иметь приоритет в дочернем контексте.

2. ConfigurableApplicationContext

ConfigurableApplicationContext является подклассом ApplicationContext, и основная задача этого интерфейса — настроить функцию контекста приложения.

[Дополнительно](https://blog.csdn.net/ligel136738/article/details/113448427)

</details>

<details>
  <summary> ApplicationEventMulticaster </summary>
ApplicationEventMulticaster — это интерфейс трансляции событий в spring, который отвечает за трансляцию и публикацию событий.

Если внутри контейнера есть bean-компонент с именем applicationEventMulticaster, это устанавливает этот bean-компонент в качестве распространителя событий в контексте.
	
Если в контейнере нет компонента, он будет по умолчанию SimpleApplicationEventMulticaster.

</details> 


<details>
  <summary> @ConfigurationPropertiesScan </summary>
В проектах SpringBoot нам часто нужно привязать некоторые элементы конфигурации с определенными префиксами к классу конфигурации. В настоящее время мы можем использовать @EnableConfigurationPropertiesаннотацию @ConfigurationPropertiesдля достижения. Аннотации также добавлены в SpringBoot 2.2.0 @ConfigurationPropertiesScan, чтобы помочь нам упростить регистрацию класса конфигурации как Bean. Далее в основном объясняется использование и реализация исходного кода этих трех аннотаций.
	
Существуют следующие элементы конфигурации, которые мы используем @ConfigurationProperties и @EnableConfigurationProperties чтобы привязать их к классам конфигурации, и эти классы конфигурации будут фактически зарегистрированы как bean-компоненты.

</details> 

<details>
  <summary> org.springframework.stereotype.Service </summary>
org.springframework.stereotype.Service — это аннотация Spring, используемая для обозначения компонентов бизнес-уровня (службы).
Отмеченный компонент должен иметь такую конфигурацию в конфигурационном файле 
```java
	< context : component-scan base-package = " имя пакета" > < /context:component-scan > 
```

Также может указывать на то, что класс является «Фасадом бизнес-службы» (в смысле шаблонов Core J2EE) или чем-то подобным. Эта аннотация является стереотипом общего назначения, и отдельные группы могут сузить свою семантику и использовать ее по мере необходимости.
</details>

		
<details>
  <summary> org.springframework.transaction.annotation.Transactional </summary>
Transactional — это аннотация транзакции, определенная в Spring, которая добавляется к методу или классу для запуска транзакции. Он в основном получает информацию об аннотациях bean-компонентов посредством отражения и использует АОП для инкапсуляции и реализации программных транзакций.
	
В некоторых бизнес-сценариях, если в запросе необходимо записать данные из нескольких таблиц или выполнить несколько SQL-запросов одновременно, чтобы обеспечить атомарность операции (одновременное успешное или неудачное выполнение) и избежать несогласованности данных, мы используем транзакции. обычно используются; в среде Spring мы часто используем аннотацию @Transactional для управления транзакциями.
	
[Транзакция](https://blog.csdn.net/minghao0508/article/details/124374637?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522166317290016800182714431%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=166317290016800182714431&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-2-124374637-null-null.142^v47^pc_rank_34_default_2,201^v3^control_1&utm_term=%40interface%20Transactional&spm=1018.2226.3001.4187) относится к логической группе операций, и единицы, составляющие эту группу операций, либо все успешны, либо все неудачны, ниже вводятся основные понятия, связанные с транзакциями.
	
ACID относится к четырем характеристикам, которыми должна обладать система управления базами данных ( СУБД ), чтобы гарантировать правильность и надежность транзакции в процессе записи или обновления данных : ACID (от англ. atomicity, consistency, isolation, durability) — набор требований к транзакционной системе, обеспечивающий наиболее надёжную и предсказуемую её работу — атомарность[⇨], согласованность[⇨], изоляция[⇨], устойчивость[⇨]; сформулированы в конце 1970-х годов Джимом Греем.

Spring предоставляет богатую функциональную поддержку для управления транзакциями. Управление транзакциями Spring делится на два способа: программный и декларативный:

1) Программная транзакция : позволяет пользователям точно определить границу транзакции в коде и реализовать ее самостоятельно, когда это необходимо бизнес-логике, через программный код с меньшей степенью детализации;

Для программного управления транзакциями используйте TransactionTemplate или непосредственно базовый PlatformTransactionManager; для программного управления транзакциями Spring рекомендует использовать TransactionTemplate;

2) Декларативная транзакция : основана на Spring AOP(Аспе́ктно-ориенти́рованное программи́рование), реализуется с помощью аннотаций или конфигурации XML, помогает пользователям отделить операции от правил транзакций;

Суть его заключается в том, чтобы перехватить метод до и после, а затем создать или присоединиться к транзакции до запуска целевого метода, и зафиксировать или откатить транзакцию в соответствии с выполнением после выполнения целевого метода; также есть два распространенных способа декларативного управление транзакциями, один из них - Сделать соответствующие объявления правил транзакций в файле конфигурации XML, а другой основан на аннотации @Transactional.Очевидно, что метод на основе аннотаций проще в использовании.

Очевидно, что декларативные транзакции лучше, чем программные транзакции, которые являются ненавязчивым методом разработки, поддерживаемым Spring ; декларативное управление транзакциями защищает бизнес-код от загрязнения, а метод нуждается в поддержке транзакций, просто добавьте аннотации;

По сравнению с программными транзакциями декларативные транзакции также имеют недостатки, поскольку на основе Spring AOP (динамический прокси) самые мелкие декларативные транзакции могут действовать только на уровне метода и не могут действовать на уровне блока кода, как программные транзакции. конечно, блоки кода, которые нуждаются в управлении транзакциями, также могут быть разделены на методы, кроме того, вызовы между аналогичными методами не будут перехватываться АОП, что приводит к недопустимым аннотациям транзакций.
	
Атрибуты транзакций можно понимать как некоторые базовые конфигурации транзакций, описывающие, как политики транзакций применяются к методам; атрибуты транзакций включают несколько аспектов: поведение распространения, правила изоляции, правила отката, тайм-аут транзакции, только для чтения или нет;

```
TransactionDefinition.PROPAGATION_REQUIRED(если есть текущая транзация, присоединить к транзакции, если текущей транзакции нет, то создайте новую транзакцию. Это значение по умолчанию)
	
TransactionDefinition.PROPAGATION_REQUIRES_NEW(создайте новую транзакцию и, если текущая транзакция существует, приостановите транзакцию)
	
TransactionDefinition.PROPAGATION_SUPPORTS(если в данный момент существует транзакция, присоединить к транзакии, если нет, то продолжать работать без транзакции)
	
TransactionDefinition.PROPAGATION_NOT_SUPPORTED(выполняется без транзакций. Если есть текущая транзакция, текущая транзакция приостанавливается)
	
TransactionDefinition.PROPAGATION_NEVER(выполняется нетранзакционным способом, если в данный момент существует транзакция, генерируется исключение)
	
TransactionDefinition.PROPAGATION_MANDATORY(если есть текущая транзакция, присоединитесь к транзакции, если текущей транзакции нет, генерируется исключение)
	
TransactionDefinition.PROPAGATION_NESTED(если транзакция существует в данный момент, создайте транзакцию для выполенения как вложенную транзакцию текущей транзакции, если в данный момент транзакции нет, то значение эквивалентно TransactionDefinition.PROPAGATION_REQUIRED)
```

</details> 

		
<details>
  <summary> @EnableWebSecurity </summary>
Во-первых, аннотация EnableWebSecurity является составной аннотацией, в которой используется аннотация @EnableGlobalAuthent

Во-первых, класс конфигурации WebSecurityConfiguration активируется в 1. В этом классе конфигурации вводится очень важный bean-компонент SpringSecurityFilterChain, который является основным фильтром Spring Secuity, который является записью аутентификации для запроса.
	
В этой аннотации активирован класс конфигурации AuthenticationConfiguration. Этот класс используется для настройки основных классов, связанных с аутентификацией. Основная функция этого класса — внедрить AuthenticationManagerBuilder в контейнер Spring. AuthenticationManagerBuilder фактически использует режим построителя, который может создавать AuthenticationManager Как упоминалось ранее, этот класс является точкой входа для аутентификации личности.

Итак, на данный момент аннотация EnableWebSecurity выполняет две функции: 1. Загрузить класс конфигурации WebSecurityConfiguration и настроить стратегию аутентификации безопасности. 2: Загружается AuthenticationConfiguration и настраивается информация аутентификации.
</details>


<details>
  <summary> IOC(Inversion of Control) </summary>
 
В программной системе объектно-ориентированного проектирования ее нижний слой состоит из N объектов, и каждый объект взаимодействует друг с другом для окончательной реализации систематической бизнес-логики. 

Если мы откроем заднюю крышку механических часов, то увидим ситуацию, похожую на описанную выше, с соответствующими шестернями, вращающими часовую, минутную и секундную стрелки по часовой стрелке, чтобы установить правильное время на циферблате. Один из таких комплектов шестерен изображен выше, который состоит из нескольких независимых шестерен, которые входят в зацепление друг с другом и работают вместе для выполнения задачи. Мы видим, что в таком наборе шестерен, если есть проблема с одной шестерней, это может повлиять на нормальную работу всего набора шестерен.
![image](https://user-images.githubusercontent.com/84707645/190708712-94dcc01d-d6fa-4cf1-8934-0be518a8d23a.png)

![image](https://user-images.githubusercontent.com/84707645/190709136-7c1aa725-713f-49a5-b1e3-23c43aecaa75.png)
IOC это декомпозиция сложной системы на объекты, которые взаимодействуют друг с другом. После того, как эти классы объектов инкапсулированы, внутренняя реализация прозрачна для внешней, что снижает сложность решения задачи, а также может быть повторно использована и гибко расширена.

После введения «третьего лица», то есть контейнера IOC, четыре объекта А, В, С и D не имеют связи сцепления, и передача между шестернями всех полагается на «третью сторону», выполняющую роль «клея» для всех объектов в системе. 

</details>
